The X Server tracks the output from any running clients, updating the display to reflect that output. The X Server also handles input from the keyboard, mouse, etc. forwarding events to the relevant client applications. User input and some other types of information like inter-client communication information, window state, and region exposure are passed from server to client as events . An event is simply a packet of information that informs the client of something that it needs to act upon, such as mouse movement. When a client receives an event, it responds by issuing a request to the server for some action affecting the display to be performed, for example requesting that a window be resized or moved. The server responds to requests by clients by updating the appropriate windows. In a modern X Server like the X.Org Server, the server is layered into two key parts. Device Independent X ( DIX ) implements the core X protocol and interacts with clients, implementing software rendering and event delivery. Device Dependent X ( DDX ) interacts with the hardware, either directly through other user space libraries such as libdrm to interact with the Direct Rendering Manager (DRM) or indirectly via libraries like OpenGL which can provide an additional layer of hardware independence, such as in the Glamor hardware independent 2D acceleration driver, which translates X render primitives to OpenGL operations.



An X client is an application program that communicates with the X Server via the X protocol. The X Window System allows multiple clients to run simultaneously, each displayed in a separate window and each potentially running on a different host due to the network transparency of the X protocol. In addition to communicating with the server, X clients also need to be able to communicate with other clients. For example a client may wish to tell the window manager, which is itself just another X client, where to place its icon. This inter-client communication is facilitated via properties, which are pieces of information associated with a window or font and stored in the server. Storing properties in the server makes the information visible to all clients. One common use for properties in inter-client communication is when a client wishes to tell the window manager the name of the application associated with its window. The name might typically correspond to the client’s name by default, but in many cases clients may specify a different name when run, such as a text editor including the name of the file being edited as part of its name. The client application’s name is stored in the server in the property called WM_NAME. The X Window System has no standard UI/UX interface nor design guidelines, which has resulted in several significantly different interfaces from XView/OLIT to CDE & Motif, though KDE/Qt and GNOME/GTK have now come to dominate.




In contrast to kernel-based window systems, where the way the window system operates is inherent to the operating system, control of the X Window System is largely concentrated in a user space process called the window manager, which is really just another X client. The look and feel of the desktop of a particular system is largely determined by the window manager being used. The window manager controls the placement and appearance of windows and commonly includes features to allow the user to open, close, minimize, maximize, move, resize, and keep track of running windows, including window decorators. Many common window managers come with a range of utilities and “applets” such as docks, task bars, application launchers, desktop icons, and wallpaper. In modern systems window managers tend to be compositing , which provide applications with an off-screen buffer for each window. The window manager composites the window buffers into an image representing the screen and writes the result into the display memory and since the screen is double buffered, it does not flicker during updates. The most common window managers currently in use include Muffin used by Cinnamon, Mutter used by GNOME and KWin used by KDE, though lightweight distributions favour window managers such as Xfvm used by Xfce and JWM, a stacking window manager used in Damn Small Linux and Puppy Linux.




It is a fundamental design principle of the X Window System that clients and servers should operate independently and be platform agnostic. Device independence and network transparency however come at a cost, though in practice most of the overhead is in the form of latency from network round-trip delay which can be minimised by good application design. To facilitate efficient IPC where the X Server and clients are running on the same host modern X11 implementations use Unix domain sockets and shared memory (via the MIT-SHM extension). Although the X protocol was well designed, and somewhat ahead of its time in 1984, it has a number of issues. Perhaps the most serious issue is that the network traffic between the X Server and X clients is not encrypted making a man-in-the-middle attack fairly trivial, though this is easily resolved by using an SSH tunnel. Another issue is that X clients cannot readily be disconnected from the server then reconnected, this problem is usually resolved by taking a different approach to network transparency, such as X Persistent Remote Applications (Xpra), Virtual Network Computing (VNC) or other Remote Desktop Protocols. Finally, modern 3D accelerated applications can be an issue and although the X11 GLX extension permits indirect rendering this can be inefficient and it is often desirable to be able to use more powerful GPUs that may exist on remote hosts. This book shall explore some options for remoting in later chapters.




Wayland is a display server protocol between a compositor (a display server that is also a compositing window manager) and its clients, as well as a library implementing the protocol. The Wayland protocol is a client-server protocol in which clients are graphical applications that can directly write data into the framebuffer using the EGL rendering API. EGL is used to avoid dependencies on X and also enables Weston to run on GPUs which don’t support the full OpenGL API. Wayland is intended as a simpler replacement for X, but although it is technically independent of X the large number of existing X Clients mean that X will be intertwined with Wayland for compatibility reasons for the foreseeable future, as illustrated by the diagram in the X11 Architecture section. Weston is a reference implementation of a Wayland compositor also developed by the Wayland project. Weston has a number of back-ends that enable it to run directly on Linux KMS, another Wayland server or on X11. Weston also supports X Clients via XWayland, which provides backwards compatibility to X applications in a Wayland stack. XWayland is activated by instructing Weston to load the XWayland module, e.g. weston --xwayland . Weston starts listening on a new X display socket, and exports it in the environment variable DISPLAY. When the first X client connects, Weston launches a special X server as a Wayland client to handle the X client and all future X clients.




In simple terms an X client is an application program that communicates with the X Server via the X protocol, usually using either the Xlib or XCB libraries to implement the client-side of the protocol. The X protocol is transmitted over the X11 socket to the X Server, which interprets the commands and renders them to the display. In order to create a containerised GUI application we will need to include the full X11 client stack in the container, including any toolkits such as GTK or Qt used by the application, in addition the application will need access to an X11 socket. There are two approaches that may be used to provide a containerised client with access to an X11 socket: The container could share the host’s X11 socket. Where the client and server are co-located the X11 socket is a Unix domain socket, so sharing it is simply a case of bind-mounting the socket’s file system name as a volume into the container.  The container could bundle a headless X Server such as Xvfb or Xorg with a dummy device and use a VNC server or similar remote desktop application to capture and export the virtual framebuffer display.  The second of these approaches is a little more complex, but potentially provides the highest level of container isolation albeit at the cost of some performance and efficiency. It will be covered later in the context of remote applications, though it may also be used for highly isolated local applications.

